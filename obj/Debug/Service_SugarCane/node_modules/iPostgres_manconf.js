
//for manage_db/add_getconfig.js

//var config = require('config_local.json');
var config_file = require('config.js');
var config = [];
config_file.getconfigdb(function (res_config) {
    config = res_config;

});

//var config = require('config_traffic.json');

var pg = require('pg');
//pg.defaults.poolSize = 20;




function iConnPG_connectstring(dbname) {
    var constring = 'postgres://' + config.pg_db.user + ':' + config.pg_db.pws + '@' + config.pg_db.host + ':' + config.pg_db.port + '/' + dbname;


    //callback(constring);
    return constring;

}
exports.iConnPG_connectstring = iConnPG_connectstring;
function iConnPG(dbname) {
    var client = new pg.Client({
        host: config.pg_db.host,
        port: config.pg_db.port,
        user: config.pg_db.user,
        password: config.pg_db.pws,
        database: dbname
    });
    return client;
}


exports.iConnPG = iConnPG;

function setcon(pg_db) {
    //debugger;
    var constring = 'postgres://' + pg_db.user + ':' + pg_db.pws + '@' + pg_db.host + ':' + pg_db.port + '/' + pg_db.dbname;
    return constring;
}

/*
setTimeout(function () {
    //  move_pg();
    // move_backup();
    // move_test();
    // list_alldb();
    //get_timeback_3month(function (res) {
    //    console.log(res);
    //});

    var t = {
        "host": "203.151.94.71",
        "port": "5432",
        "user": "postgres",
        "pws": "passw0rd",
        "dbname": "dbu_100001"
    }

    debugger;

    console.log(setcon(t));


}, 1000);
*/



iGcon = function () {
    return conn = new iConnPG();
}


exports.iGcon = function () {
    return conn = new iConnPG();
}

var client = null;
var _dbname = '';

exports.set_db = function (dbname) {
    _dbname = dbname;
    if (client != null) {
        client.end.bind(client);
        client = null;
        connect();
    } else {
        connect();
    }

}

function connect() {
    client = iConnPG(_dbname);
    //  conn.database = dbname;
    client.on('drain', client.end.bind(client));
    client.connect();
}




//#region for pool




exports.iNonQuery = function (dbname, sql, callback) {

    // var client = iConnPG(dbname); //new pg.Client(conString);
    try {
        var conString = setcon(dbname);

        pg.connect(conString, function (err, client, done) {
            //debugger;
            if (err) {
                console.log("NonConnect err.code = " + err.code + " err.message " + err.message);
                callback("error");
                return write_err(err, sql, "iNonQuery5");
            }

            client.query(sql, function (err, result) {
                done();

                if (err) {
                    // return write_err(err, sql, "iNonQuery2");
                    console.log("Nonquery err.code = " + err.code + " err.message " + err.message);
                    callback(err.code);
                    return;
                }
                else {
                    //   console.log(result.command);
                    callback("ok");
                    return;
                }
            });
        });
    }
    catch (e) {
        debugger;
        console.log("Nonquery " + e.message);
        callback("error");
        return;
    }
}



exports.iScalr = function (dbname, sql, callback) {

    var conString = setcon(dbname);
    pg.connect(conString, function (err, client, done) {
        if (err) {
            callback('0');
            return write_err(err, sql, "iScalr1");
        }
        client.query(sql, function (err, result) {
            //debugger;
            done();

            if (err) {
                callback('0');
                return write_err(err, sql, "iScalr2");
            }
            else {
                if (result.rowCount != 0) {
                    var name = result.fields["0"].name;
                    res = result.rows["0"][name];
                    callback(res);
                    return;
                }
                else {
                    callback('0');
                    return;

                }

            }

        });
    });

}
exports.iScalrCommand = function (client, sql, callback) {


    client.query(sql, function (err, result) {
        //debugger;
        // done();

        if (err) {
            callback('0');
            return write_err(err, sql, "iScalr2");
        }
        else {
            if (result.rowCount != 0) {
                var name = result.fields["0"].name;
                res = result.rows["0"][name];
                callback(res);
                return;
            }
            else {
                callback('0');
                return;

            }

        }

    });


}
exports.iArray = function (dbname, sql, callback) {

    var conString = setcon(dbname);
    pg.connect(conString, function (err, client, done) {
        //debugger;
        if (err) {
            return write_err(err, sql, "iArray1");
        }
        client.query(sql, function (err, result) {
            done();

            if (err) {
                return write_err(err, sql, "iArray2");
            }
            else {
                callback(result.rows);
                return;
            }


        });
    });

}

exports.iArrayCommand = function (client, sql, callback) {


    client.query(sql, function (err, result) {
        //  done();

        if (err) {
            return write_err(err, sql, "iArray2");
        }
        else {
            callback(result.rows);
            return;
        }


    });


}

function write_err(err, sql, method) {
    console.error('error ' + method + ' running query \r\n ', err + "\r\n : " + sql);
}

//#endregion

//#region for tcp
exports.iExitsDB = function (dbname, callback) {
    var sql = 'SELECT count(datname) FROM pg_database WHERE datname=' + "'" + dbname + "'";
    exports.iScalr('postgres', sql, function (res) {
        callback(res);
        return;
    });

}


//setTimeout(function () { copy_znomail(); }, 1000);

function copy_znomail() {
    //  COPY <TargetTableName> FROM '/path/to/csv/SourceCSVFile.csv'  DELIMITERS  ','  CSV;
    var sql = "SELECT serial_sim,data FROM raw_data WHERE serial_sim='8966180806144732423'";

    //ipg.iArray('z_no_mail', sql, function (ar) {
    //    // console.log(items);
    //    if (ar.length > 0) {
    //        json2csv({ data: ar, fields: ['serial_sim', 'data'] }, function (err, csv) {



    //        });
    //    }
    //});
    debugger;
    var dbname = 'test_movez@dtc';
    var conString = setcon(dbname);
    pg.connect(conString, function (err, client, done) {

        //var client = new Client({ user: 'brianc', database: 'test' });
        client.connect();
        var stream = client.copyFrom("COPY raw_data (serial_sim, data) FROM STDIN WITH CSV");
        stream.on('close', function () {
            console.log("Data inserted sucessfully");
        });
        stream.on('error', function (error) {
            console.log("Sorry, error happens", error);
        });
        stream.write("8966180806144732423,#N808:8966180806144732423:DE00000:060:4:100:0:120:01998:B:I:1:0.000:*N5051273430217900648865E8220D00A872002170FF00000F000803*N5051273429707900648865E8220D00A872002170FF00000F000903**08\n");
        stream.write("8966180806144732423,#N808:8966180806144732423:DE00000:060:4:100:0:120:01998:B:I:1:0.000:*N5051273430437900648865E8220D00A872002170FF00000F000703*N5051273430327900648865E8220D00A872002170FF00000F000903**08\n");
        stream.write("8966180806144732423,#N808:8966180806144732423:DE00000:060:4:100:0:120:01998:B:I:1:0.000:*N5051273430657800648865E8220D00A872002170FF00000F000803*N5051273430547800648865E8220D00A872002170FF00000F000803**08\n");
        //stream.write("user1,10\n");
        //it's possible to combine more than one row in one write operation
        //stream.write("user2,20\nuser3,30\n");
        //it's not required to match row ending to write operation
        //stream.write("user4");
        //stream.write(",40\nuser5,50\n");
        //tell the sever that we've sent all data we have
        stream.end();

    });

}

//#endregion


function _query_ar(ipg_man, para, cb) {

    ipg_man.iArray(para.config_con, para.sql, function (ar) {
        // console.log(ar);
        cb(ar);
        return;
    });


}

function _iexcute(ipg_man, para, callback) {
    ipg_man.iNonQuery(para.config_con, para.sql, function (is_ok) {
        callback(is_ok);
        return;
    });
}

exports._query_ar = _query_ar;
exports._iexcute = _iexcute;

//v0.1
//fix show result error query


